- name: Generic MicroStrategy Restart Framework
  hosts: localhost
  gather_facts: no

  vars:
    ocp_api: https://api.ocp.example.com:6443
    cluster_name: ocp-prod-01
    namespace: mstr-sandbox01
    log_dir: /var/log/mstr-ansible

    restart_targets:
      - name: library
        kind: deployment
        pattern: library
      - name: iserver
        kind: statefulset
        pattern: iserver
      - name: biweb
        kind: deployment
        pattern: biweb

  vars_prompt:
    - name: ocp_user
      prompt: "Enter OCP Username ID"
      private: no
    - name: ocp_pass
      prompt: "Enter OCP Password"
      private: yes

  pre_tasks:
    - name: Capture audit details
      set_fact:
        run_user: "{{ lookup('env','USER') }}"
        run_time: "{{ lookup('pipe','date +%Y-%m-%d_%H-%M-%S') }}"

    - name: Ensure log directory exists
      file:
        path: "{{ log_dir }}"
        state: directory
        mode: '0777'

    - debug:
        msg: |
          ==================================================
          MicroStrategy OCP Restart Run
          Cluster  : {{ cluster_name }}
          User     : {{ run_user }}
          Time     : {{ run_time }}
          ==================================================

  tasks:
    - name: Login to OpenShift
      command: >
        oc login {{ ocp_api }} -u {{ ocp_user }} -p {{ ocp_pass }} --insecure-skip-tls-verify

    - name: Initialize log
      set_fact:
        log_content: |
          MicroStrategy OCP Restart Run
          Cluster: {{ cluster_name }}
          User: {{ run_user }}
          Time: {{ run_time }}

    - name: Process restart targets
      loop: "{{ restart_targets }}"
      loop_control:
        label: "{{ item.name }}"
      block:

        - debug:
            msg: ">>> Processing {{ item.name | upper }} ({{ item.kind }})"

        - name: Discover resource
          shell: |
            case "{{ item.kind }}" in
              deployment) oc get deployment -n {{ namespace }} --no-headers | grep -i {{ item.pattern }} | awk '{print $1}' ;;
              statefulset) oc get statefulset -n {{ namespace }} --no-headers | grep -i {{ item.pattern }} | awk '{print $1}' ;;
            esac
          register: res

        - set_fact:
            target_name: "{{ res.stdout_lines[0] }}"

        - name: Find BEFORE pod
          shell: oc get pod -n {{ namespace }} --no-headers | grep {{ target_name }} | awk '{print $1}' | head -1
          register: before_pod

        - shell: oc get pod {{ before_pod.stdout }} -n {{ namespace }} --no-headers
          register: before_out

        - set_fact:
            log_content: "{{ log_content }}\n\n{{ item.name }} BEFORE:\n{{ before_out.stdout }}"

        - name: Restart resource
          shell: |
            case "{{ item.kind }}" in
              deployment) oc rollout restart deployment {{ target_name }} -n {{ namespace }} ;;
              statefulset) oc rollout restart statefulset {{ target_name }} -n {{ namespace }} ;;
            esac

        - name: Find new pod
          shell: oc get pod -n {{ namespace }} --no-headers | grep {{ target_name }} | grep -v Terminating | awk '{print $1}' | head -1
          register: new_pod
          until: new_pod.stdout != ""
          retries: 60
          delay: 10

        # ---- PROVEN WORKING CORE ----
        - name: Wait until pod is Running
          shell: oc get pod {{ new_pod.stdout }} -n {{ namespace }} -o jsonpath='{.status.phase}'
          register: phase
          until: phase.stdout == "Running"
          retries: 60
          delay: 10

        - name: Wait until all containers Ready
          shell: oc get pod {{ new_pod.stdout }} -n {{ namespace }} -o jsonpath='{.status.containerStatuses[*].ready}'
          register: ready
          until: "'false' not in ready.stdout"
          retries: 60
          delay: 10

        - debug:
            msg: "SUCCESS {{ item.name }} â†’ {{ new_pod.stdout }} ({{ phase.stdout }}, {{ ready.stdout }})"

        - shell: oc get pod {{ new_pod.stdout }} -n {{ namespace }} --no-headers
          register: after_out

        - set_fact:
            log_content: "{{ log_content }}\n{{ item.name }} AFTER:\n{{ after_out.stdout }}"

    - name: Save full run output to log archive
      copy:
        dest: "{{ log_dir }}/mstr_restart_{{ run_time }}.log"
        content: "{{ log_content }}"
