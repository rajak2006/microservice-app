1Ô∏è‚É£ Find Library pod BEFORE restart

Add this after Set Library deployment

- name: Find Library pod (BEFORE)
  shell: |
    oc get pod -n {{ namespace }} --no-headers \
    | grep {{ library_deployment }} \
    | awk '{print $1}' | head -1
  register: lib_pod_before

2Ô∏è‚É£ BEFORE status (same format as IServer)
- name: Show BEFORE status
  shell: |
    echo "================ BEFORE STATUS ================"
    oc get pod {{ lib_pod_before.stdout }} -n {{ namespace }}
    oc get pod {{ iserver_pod }} -n {{ namespace }}
    echo "=============================================="
  register: before_status

- debug:
    msg: "{{ before_status.stdout }}"

3Ô∏è‚É£ Restart (no change)

Your restart tasks stay as they are.

4Ô∏è‚É£ Find NEW Library pod AFTER restart
- name: Find Library pod (AFTER)
  shell: |
    oc get pod -n {{ namespace }} --no-headers \
    | grep {{ library_deployment }} \
    | awk '{print $1}' | head -1
  register: lib_pod_after

5Ô∏è‚É£ AFTER status (same as IServer)
- name: Show AFTER status
  shell: |
    echo "================ AFTER STATUS ================"
    oc get pod {{ lib_pod_after.stdout }} -n {{ namespace }}
    oc get pod {{ iserver_pod }} -n {{ namespace }}
    echo "============================================="
  register: after_status

- debug:
    msg: "{{ after_status.stdout }}"

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
good
- name: MicroStrategy Library & IServer Restart
  hosts: localhost
  gather_facts: no
  vars_files:
    - vars.yml

  vars_prompt:
    - name: ocp_user
      prompt: "Enter OCP Username (FID)"
      private: no
    - name: ocp_pass
      prompt: "Enter OCP Password"
      private: yes

  pre_tasks:
    - name: Capture audit details
      set_fact:
        run_user: "{{ lookup('env','USER') }}"
        run_time: "{{ lookup('pipe','date +%Y-%m-%d_%H-%M-%S') }}"

    - name: Show run mode
      debug:
        msg: >
          Running in {{ 'DRY-RUN (no changes)' if dry_run else 'REAL EXECUTION' }} mode

  tasks:

  - name: Login to OpenShift
    command: >
      oc login {{ ocp_api }} -u {{ ocp_user }} -p {{ ocp_pass }} --insecure-skip-tls-verify

  - name: Find Library deployment
    shell: oc get deployment -n {{ namespace }} --no-headers | awk '{print $1}' | grep -i {{ library_pattern }}
    register: lib_name

  - name: Set Library deployment
    set_fact:
      library_deployment: "{{ lib_name.stdout_lines[0] }}"

  - name: Find IServer pod
    shell: oc get pod -n {{ namespace }} --no-headers | awk '{print $1}' | grep -i {{ iserver_pattern }} | head -1
    register: isrv_name

  - name: Set IServer pod
    set_fact:
      iserver_pod: "{{ isrv_name.stdout }}"

  - name: Show discovered components
    debug:
      msg:
        - "Library Deployment: {{ library_deployment }}"
        - "IServer Pod: {{ iserver_pod }}"

  - name: Show AUDIT header
    debug:
      msg: |
        ==================================================
        MicroStrategy OCP Restart Run
        Cluster     : {{ cluster_name }}
        Namespace   : {{ namespace }}
        Run By      : {{ run_user }}
        Run Time    : {{ run_time }}
        Library     : {{ library_deployment }}
        IServer Pod : {{ iserver_pod }}
        ==================================================

  - name: Show BEFORE status
    shell: |
      echo "================ BEFORE STATUS ================"
      oc get deployment {{ library_deployment }} -n {{ namespace }}
      echo ""
      oc get pod {{ iserver_pod }} -n {{ namespace }}
      echo "=============================================="
    register: before_status

  - debug:
      msg: "{{ before_status.stdout }}"

  - name: Dry-run message
    debug:
      msg:
        - "DRY-RUN: Would restart deployment {{ library_deployment }}"
        - "DRY-RUN: Would delete pod {{ iserver_pod }}"
    when: dry_run

  - name: Restart Library deployment
    command: oc rollout restart deployment {{ library_deployment }} -n {{ namespace }}
    when: not dry_run

  - name: Restart IServer pod
    command: oc delete pod {{ iserver_pod }} -n {{ namespace }}
    when: not dry_run

  - name: Wait for Library
    command: oc rollout status deployment {{ library_deployment }} -n {{ namespace }} --timeout=300s
    when: not dry_run

  - name: Wait for IServer
    shell: oc get pod {{ iserver_pod }} -n {{ namespace }} -o jsonpath='{.status.phase}'
    register: pod_state
    until: pod_state.stdout == "Running"
    retries: 20
    delay: 15
    when: not dry_run

  - name: Final pod check
    command: oc get pod {{ iserver_pod }} -n {{ namespace }}
    register: final

  - name: Fail if unhealthy
    fail:
      msg: "IServer unhealthy: {{ final.stdout }}"
    when: final.stdout is search("CrashLoopBackOff|Error|ImagePullBackOff")

  - name: Show AFTER status
    shell: |
      echo "================ AFTER STATUS ================"
      oc get deployment {{ library_deployment }} -n {{ namespace }}
      echo ""
      oc get pod {{ iserver_pod }} -n {{ namespace }}
      echo "============================================="
    register: after_status

  - debug:
      msg: "{{ after_status.stdout }}"

  - name: Save full run output to log archive
    copy:
      dest: "/var/log/mstr-ansible/mstr_restart_{{ run_time }}.log"
      content: |
        ==================================================
        MicroStrategy OCP Restart Run
        ==================================================
        Cluster     : {{ cluster_name }}
        Namespace   : {{ namespace }}
        Run By      : {{ run_user }}
        Run Time    : {{ run_time }}
        Library     : {{ library_deployment }}
        IServer Pod : {{ iserver_pod }}

        ---------------- BEFORE ----------------
        {{ before_status.stdout }}

        ---------------- AFTER -----------------
        {{ after_status.stdout }}

        ==================================================


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Perfect, that‚Äôs the **right design** üëç
We should **auto-discover** the *library* and *iserver* instead of hard-coding names.

Below is the **improved production playbook** where Ansible:

> üîç **Finds library deployment & iserver pod dynamically**
> ‚ôªÔ∏è Restarts them safely
> ‚è≥ Waits until healthy
> ‚ùå Fails on CrashLoopBackOff / Error

---

# üìÅ vars.yml

```yaml
ocp_api: https://api.ocp-cluster.example.com:6443
ocp_token: "{{ lookup('env','OCP_TOKEN') }}"
namespace: matr-env

library_pattern: "library"
iserver_pattern: "iserver"
```

---

# üìÑ mstr_restart.yml (Dynamic Discovery)

```yaml
- name: Restart MicroStrategy core services (auto-discovery)
  hosts: localhost
  gather_facts: no
  vars_files:
    - vars.yml

  tasks:

  - name: Login to OpenShift
    command: >
      oc login {{ ocp_api }} --token={{ ocp_token }} --insecure-skip-tls-verify
    register: login_out
    failed_when: "'Login successful' not in login_out.stdout"

  # -------- Discover Library Deployment --------
  - name: Find Library deployment
    shell: |
      oc get deployment -n {{ namespace }} --no-headers | awk '{print $1}' | grep -i {{ library_pattern }}
    register: lib_name

  - name: Set library deployment
    set_fact:
      library_deployment: "{{ lib_name.stdout_lines[0] }}"

  # -------- Discover IServer Pod --------
  - name: Find IServer pod
    shell: |
      oc get pod -n {{ namespace }} --no-headers | awk '{print $1}' | grep -i {{ iserver_pattern }} | head -1
    register: isrv_name

  - name: Set iserver pod
    set_fact:
      iserver_pod: "{{ isrv_name.stdout }}"

  - name: Show discovered components
    debug:
      msg:
        - "Library Deployment: {{ library_deployment }}"
        - "IServer Pod: {{ iserver_pod }}"

  # -------- Restart --------
  - name: Restart Library deployment
    command: oc rollout restart deployment {{ library_deployment }} -n {{ namespace }}

  - name: Restart IServer pod
    command: oc delete pod {{ iserver_pod }} -n {{ namespace }}

  # -------- Wait --------
  - name: Wait for Library
    command: oc rollout status deployment {{ library_deployment }} -n {{ namespace }} --timeout=300s

  - name: Wait for IServer
    shell: oc get pod {{ iserver_pod }} -n {{ namespace }} -o jsonpath='{.status.phase}'
    register: pod_state
    until: pod_state.stdout == "Running"
    retries: 20
    delay: 15

  # -------- Validate --------
  - name: Final pod check
    command: oc get pod {{ iserver_pod }} -n {{ namespace }}
    register: final

  - name: Fail if unhealthy
    fail:
      msg: "IServer unhealthy: {{ final.stdout }}"
    when: final.stdout is search("CrashLoopBackOff|Error|ImagePullBackOff")

  - debug:
      msg: "{{ final.stdout }}"
```

---

# ‚ñ∂Ô∏è Run

```bash
export OCP_TOKEN=sha256~xxxxx
ansible-playbook -i inventory mstr_restart.yml
```

---

## ‚úÖ Now your playbook:

* Works in **any environment**
* No hardcoding
* Auto adapts to new MSTR env names

---

If you want, next I can:

* Restart **all MSTR pods**
* Add **change detection**
* Or make it a **role-based reusable framework** üí°
+++++++++++++++@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Excellent question, Raj ‚Äî this is a **real enterprise design decision**, not just a technical one üëç

Here‚Äôs the **clear, production-grade answer** used in banks & regulated environments.

---

# üîê OCP Login: Service Account vs FID (LDAP User)

| Feature         | **Service Account (SA)**  | **FID / LDAP User**               |
| --------------- | ------------------------- | --------------------------------- |
| Identity type   | Non-human (machine)       | Human (employee)                  |
| Password        | ‚ùå No password             | ‚úÖ Password / MFA                  |
| Token           | Auto-generated, rotatable | Generated from user login         |
| MFA             | ‚ùå Not supported           | ‚úÖ Required                        |
| Automation safe | ‚úÖ **Yes**                 | ‚ùå No (breaks MFA)                 |
| Rotation        | Easy & automated          | Manual                            |
| Least privilege | Easy via RoleBinding      | Often over-privileged             |
| Audit trails    | Service name shows        | Human name (wrong for automation) |
| Expiry          | Configurable              | Short lived                       |
| Security risk   | Low (scoped)              | High (password reuse risk)        |
| Compliance      | SOC2, ISO27001 aligned    | ‚ùå Usually rejected                |

---

# üèÜ **Enterprise Best Practice**

> **Use Service Account tokens for all automation**
> (Ansible, CI/CD, CronJobs, Operators)

FID users must be **only for humans**.

---

# üîë Recommended Pattern

```text
Ansible / Jenkins / GitLab
        |
        v
Service Account (RBAC limited)
        |
        v
OpenShift API
```

---

# üõ†Ô∏è How Banks Implement This

### 1. Create Service Account

```bash
oc create sa mstr-automation -n matr-env
```

### 2. Give only required access

```bash
oc create role mstr-restart-role \
  --verb=get,list,delete,patch \
  --resource=pods,deployments \
  -n matr-env

oc create rolebinding mstr-automation-bind \
  --role=mstr-restart-role \
  --serviceaccount=matr-env:mstr-automation \
  -n matr-env
```

### 3. Get Token

```bash
oc create token mstr-automation -n matr-env
```

### 4. Use in Ansible

```bash
export OCP_TOKEN=sha256~xxxxx
```

---

# üö´ Why **NOT** FID?

* Breaks when user leaves org
* MFA blocks automation
* Token expires quickly
* Violates least privilege
* Audit confusion (looks like human did it)

---

## üìå Summary

| Use Case              | Login Method      |
| --------------------- | ----------------- |
| Ansible automation    | ‚úÖ Service Account |
| Jenkins / GitOps      | ‚úÖ Service Account |
| Human troubleshooting | ‚úÖ FID             |
| Production automation | ‚ùå Never FID       |

---

If you want, I can provide:

* Token rotation automation
* RBAC matrix for MSTR operator
* Compliance audit mapping (ISO/SOC2)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Yes ‚Äî **100% YES** üëç
In enterprise production, the **correct pattern** is:

> üîê **Service Account Token ‚Üí Encrypted with Ansible Vault ‚Üí Used by playbooks**

This is **industry standard** (banks, pharma, telecom).

Below are **clear step-by-step enterprise workflow**.

---

# üõ°Ô∏è Secure Token Storage with Ansible Vault

## 1Ô∏è‚É£ Create vault file

```bash
ansible-vault create group_vars/all/vault.yml
```

It will open an editor.

Add:

```yaml
vault_ocp_token: sha256~xxxxxxxxxxxxxxxxxxxxxxxx
```

Save & exit.

---

## 2Ô∏è‚É£ Reference token securely

Edit `vars.yml`:

```yaml
ocp_api: https://api.ocp-cluster.example.com:6443
namespace: matr-env

ocp_token: "{{ vault_ocp_token }}"
```

---

## 3Ô∏è‚É£ Update your playbook login task

```yaml
- name: Login to OpenShift
  command: >
    oc login {{ ocp_api }} --token={{ ocp_token }} --insecure-skip-tls-verify
```

---

## 4Ô∏è‚É£ Run playbook

### Option A ‚Äì Prompt for vault password

```bash
ansible-playbook mstr_restart.yml -i inventory --ask-vault-pass
```

### Option B ‚Äì Vault password file (CI/CD)

```bash
ansible-playbook mstr_restart.yml -i inventory \
  --vault-password-file /etc/ansible/.vault_pass
```

> `/etc/ansible/.vault_pass` should be:

```bash
chmod 600 /etc/ansible/.vault_pass
```

---

## 5Ô∏è‚É£ Token Rotation (Best Practice)

```bash
oc create token mstr-automation -n matr-env --duration=24h
```

Update vault:

```bash
ansible-vault edit group_vars/all/vault.yml
```

---

# üèÜ Security Compliance Mapping

| Control              | How satisfied     |
| -------------------- | ----------------- |
| Secret encryption    | Ansible Vault     |
| Least privilege      | SA + RBAC         |
| Token rotation       | `oc create token` |
| Audit logs           | SA name in OCP    |
| No hardcoded secrets | ‚úî                 |

---

If you want next, I can:

* Add **auto token rotation**
* Add **HashiCorp Vault integration**
* Or **Jenkins secret injection**
